#include <math.h>
#include <iostream>
#include "bam.h"

#include "bam32Lookups.h" // Autogenerated tables and constants

namespace bam {

    // =============== Conversion Constants ===============================
    // These are the effective precisions in radians for each BAMS tick
    const double BAMS16_TO_RAD = 9.58737992e-5;
    const double BAMS32_TO_RAD = 1.46291808e-9;
    const double BAMS64_TO_RAD = 3.4061216e-19;

    const double RAD_TO_BAMS16 = 10430.3783505;
    const double RAD_TO_BAMS32 = 683565275.576;
    const double RAD_TO_BAMS64 = 2.9358905e+18;

    // Other constants
    const double _2PI = 6.28318531;
    const double PI_4 = 0.785398163;

    inline double WrapToPi(double angle) {

        angle = fmod(angle + M_PI, 2*M_PI);
        if (angle < 0)
            angle += 2*M_PI;
        return angle - M_PI;

    }

    void BAM32::SetFromDouble(double d) {
        val = (BinaryType) RAD_TO_BAMS32*WrapToPi(d);
    }

    BAM32::BAM32() :
    val(0) {}

    BAM32::BAM32(BinaryType b) :
    val(b) {}

    BAM32::BAM32(const BAM32& other) :
    val(other.val) {}

    BAM32::BAM32(const double d) :
    val( RAD_TO_BAMS32*WrapToPi(d) ) {}

    double BAM32::ToDouble() const {
        return val*BAMS32_TO_RAD;
    }

    inline BAM32::BinaryType BAM32::ToBinary() const {
        return val;
    }
    
    // Unary operators
    BAM32 BAM32::operator+() const {
        BAM32 b(*this);
        return b;
    }

    BAM32 BAM32::operator-() const {
        BAM32 b;
        b.val = -val;
        return b;
    }

    BAM32& BAM32::operator++() {
        val++;
        return *this;
    }

    BAM32& BAM32::operator--() {
        val--;
        return *this;
    }

    BAM32 BAM32::operator++(int) {
        BAM32 tmp(*this);
        operator++();
        return tmp;
    }

    BAM32 BAM32::operator--(int) {
        BAM32 tmp(*this);
        operator--();
        return tmp;
    }

    BAM32& BAM32::operator=(const BAM32& rhs) {
        val = rhs.val;
        return *this;
    }

    BAM32& BAM32::operator=(double rhs) {
      SetFromDouble(rhs);
    }

    // Member binary operators
    BAM32& BAM32::operator+=(const BAM32& rhs) {
        val += rhs.val;
        return *this;
    }

    BAM32& BAM32::operator-=(const BAM32& rhs) {
        val -= rhs.val;
        return *this;
    }

    BAM32& BAM32::operator*=(int n) {
        val *= n;
        return *this;
    }

    BAM32& BAM32::operator*=(double d) {
        SetFromDouble(ToDouble()*d);
        return *this;
    }

    BAM32& BAM32::operator/=(int n) {
        val /= n;
        return *this;
    }

    BAM32& BAM32::operator/=(double d) {
        SetFromDouble(ToDouble()/d);
        return *this;
    }

    // Non-member binary operators
    BAM32 operator+(BAM32 lhs, const BAM32& rhs) {
        lhs += rhs;
        return lhs;
    }

    BAM32 operator-(BAM32 lhs, const BAM32& rhs) {
        lhs -= rhs;
        return lhs;
    }

    BAM32 operator*(BAM32 b, int n) {
        b *= n;
        return b;
    }

    BAM32 operator*(BAM32 b, double d) {
        b *= d;
        return b;
    }

    BAM32 operator*(int n, BAM32 b) {
        return operator*(b, n);
    }

    BAM32 operator*(double d, BAM32 b) {
        return operator*(b, d);
    }

    BAM32 operator/(BAM32 b, int n) {
        b /= n;
        return b;
    }
    
    BAM32 operator/(BAM32 b, double d) {
        b /= d;
        return b;
    }
    
    std::ostream& operator<<(std::ostream& os, const BAM32& b) {
        os << b.ToDouble();
        return os;
    }

    double bamSinFast(const BAM32& a)
    {
        //BAM32::BinaryType b = a.ToBinary();
        BAM32::BinaryType b = a.val;

        if(b < 0) {
            if(b < -BAM32::PI_2) {
                return -BAM32_SIN_TABLE[(BAM32_INDEX_MASK & b) >> BAM32_NUM_NONSIG_BITS];
            }
            else {
                return -BAM32_SIN_TABLE[(BAM32_INDEX_MASK & ~b) >> BAM32_NUM_NONSIG_BITS];
            }
        }
        else {
            if(b > BAM32::PI_2) {
                return BAM32_SIN_TABLE[(BAM32_INDEX_MASK & ~b) >> BAM32_NUM_NONSIG_BITS];
            }
            else {
                return BAM32_SIN_TABLE[(BAM32_INDEX_MASK & b) >> BAM32_NUM_NONSIG_BITS];
            }
        }
    }

    double bamCosFast(const BAM32& b) {
        // cos(x) = sin(x + pi/2)
        return bamSinFast(b + BAM32::PI_2);

    }

    double bamSin(const BAM32& a)
    {
        BAM32::BinaryType b = a.val;
        BAM32 a1( b + (1 << BAM32_NUM_NONSIG_BITS) );
        double r((b & BAM32_NONSIG_MASK)*BAM32_SIN_INTERP_RATIO);
        return (1.0 - r)*bamSinFast(a) + r*bamSinFast(a1);
    }

    double bamCos(const BAM32& a)
    {
        return bamSin(a + BAM32::PI_2);
    }
 
    // Standard precision implementation
    BAM32 bamAsinFast(double f)
    {
        if(f >= 0.0) {
            unsigned int index = (unsigned int) (f*BAM32_ASIN_NUM_VALUES);
            return BAM32_ASIN_TABLE[index];
        } else {
            unsigned int index = (unsigned int) (-f*BAM32_ASIN_NUM_VALUES);
            return -BAM32_ASIN_TABLE[index];
        }
    }

    BAM32 bamAcosFast(double f)
    {
        return bamAsinFast(f) + BAM32::PI_2;
    }

    BAM32 bamAsin(double f)
    {
        double fract, pint;
        unsigned int index;
        BAM32::BinaryType b1, b2, db;

        if(f >= 0.0) {
            fract = modf(f*BAM32_ASIN_NUM_VALUES, &pint);
            index = (unsigned int) pint;
            b1 = BAM32_ASIN_TABLE[index];
            b2 = BAM32_ASIN_TABLE[index + 1];
            db = (unsigned int) (fract*(b2 - b1));
            BAM32 ret(b1 + db);
            return ret;
        } else {
            fract = modf(-f*BAM32_ASIN_NUM_VALUES, &pint);
            index = (unsigned int) pint;
            b1 = BAM32_ASIN_TABLE[index];
            b2 = BAM32_ASIN_TABLE[index + 1];
            db = (unsigned int) (fract*(b2 - b1));
            BAM32 ret(-(b1 + db));
            return ret;
        }
    }

    BAM32 bamAcos(double f)
    {
        return bamAsin(f) + BAM32::PI_2;
    }

    BAM32 bamAtan2(double y, double x)
    {
        double div;
        unsigned char yneg, xneg, invert, temp;
        BAM32::BinaryType b, v;

        yneg = y < 0.0;
        xneg = x < 0.0;

        y = (yneg) ? -y : y;
        x = (xneg) ? -x : x;

        // Add pi/2 to tan argument and flip the tan
        // This lets us use a quarter table
        if(y > x) {
            div = x/y;
            temp = yneg;
            yneg = xneg;
            xneg = temp;
            invert = 1;
        } else {
            div = y/x;
            invert = 0;
        }

        b = BAM32_ATAN_TABLE[(unsigned int) (div*BAM32_ATAN_NUM_VALUES)];
        b = (xneg) ? BAM32::PI - b : b;
        b = (yneg) ? -b : b;
        v = (invert) ? -b + BAM32::PI_2 : b;
        BAM32 ret(v);
        return ret;
    }

} //end namespace bams
